
AVRASM ver. 2.1.52  D:\Workshop\AVR\LittleThermo\LittleThermo\LittleThermo\LittleThermo.asm Fri Oct 17 00:01:25 2014

[builtin](2): Including file 'C:\Program Files (x86)\Atmel\Atmel Toolchain\AVR Assembler\Native\2.1.1117\avrassembler\Include\tn13def.inc'
D:\Workshop\AVR\LittleThermo\LittleThermo\LittleThermo\LittleThermo.asm(8): Including file 'D:\Workshop\AVR\LittleThermo\LittleThermo\LittleThermo\avr.inc'
D:\Workshop\AVR\LittleThermo\LittleThermo\LittleThermo\LittleThermo.asm(145): Including file 'D:\Workshop\AVR\LittleThermo\LittleThermo\LittleThermo\1-wire.asm'
D:\Workshop\AVR\LittleThermo\LittleThermo\LittleThermo\1-wire.asm(24): Including file 'D:\Workshop\AVR\LittleThermo\LittleThermo\LittleThermo\wait.asm'
D:\Workshop\AVR\LittleThermo\LittleThermo\LittleThermo\1-wire.asm(168): Including file 'D:\Workshop\AVR\LittleThermo\LittleThermo\LittleThermo\1-Wire Search.asm'
                 
                 /*
                 
                 ;***** Created: 2011-02-09 12:03 ******* Source: ATtiny13.xml ************
                 ;*************************************************************************
                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                 ;* 
                 ;* Number            : AVR000
                 ;* File Name         : "tn13def.inc"
                 ;* Title             : Register/Bit Definitions for the ATtiny13
                 ;* Date              : 2011-02-09
                 ;* Version           : 2.35
                 ;* Support E-mail    : avr@atmel.com
                 ;* Target MCU        : ATtiny13
                 ;* 
                 ;* DESCRIPTION
                 ;* When including this file in the assembly program file, all I/O register 
                 ;* names and I/O register bit names appearing in the data book can be used.
                 ;* In addition, the six registers forming the three data pointers X, Y and 
                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                 ;* SRAM is also defined 
                 ;* 
                 ;* The Register names are represented by their hexadecimal address.
                 ;* 
                 ;* The Register Bit names are represented by their bit number (0-7).
                 ;* 
                 ;* Please observe the difference in using the bit names with instructions
                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                 ;* (skip if bit in register set/cleared). The following example illustrates
                 ;* this:
                 ;* 
                 ;* in    r16,PORTB             ;read PORTB latch
                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                 ;* out   PORTB,r16             ;output to PORTB
                 ;* 
                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                 ;* rjmp  TOV0_is_set           ;jump if set
                 ;* ...                         ;otherwise do something else
                 ;*************************************************************************
                 
                 #ifndef _TN13DEF_INC_
                 #define _TN13DEF_INC_
                 
                 
                 #pragma partinc 0
                 
                 ; ***** SPECIFY DEVICE ***************************************************
                 .device ATtiny13
                 #pragma AVRPART ADMIN PART_NAME ATtiny13
                 .equ	SIGNATURE_000	= 0x1e
                 .equ	SIGNATURE_001	= 0x90
                 .equ	SIGNATURE_002	= 0x07
                 
                 #pragma AVRPART CORE CORE_VERSION V2
                 #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
                 
                 
                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                 ; NOTE:
                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                 ; and cannot be used with IN/OUT instructions
                 .equ	SREG	= 0x3f
                 .equ	SPL	= 0x3d
                 .equ	GIMSK	= 0x3b
                 .equ	GIFR	= 0x3a
                 .equ	TIMSK0	= 0x39
                 .equ	TIFR0	= 0x38
                 .equ	SPMCSR	= 0x37
                 .equ	OCR0A	= 0x36
                 .equ	MCUCR	= 0x35
                 .equ	MCUSR	= 0x34
                 .equ	TCCR0B	= 0x33
                 .equ	TCNT0	= 0x32
                 .equ	OSCCAL	= 0x31
                 .equ	TCCR0A	= 0x2f
                 .equ	DWDR	= 0x2e
                 .equ	OCR0B	= 0x29
                 .equ	GTCCR	= 0x28
                 .equ	CLKPR	= 0x26
                 .equ	WDTCR	= 0x21
                 .equ	EEAR	= 0x1e
                 .equ	EEDR	= 0x1d
                 .equ	EECR	= 0x1c
                 .equ	PORTB	= 0x18
                 .equ	DDRB	= 0x17
                 .equ	PINB	= 0x16
                 .equ	PCMSK	= 0x15
                 .equ	DIDR0	= 0x14
                 .equ	ACSR	= 0x08
                 .equ	ADMUX	= 0x07
                 .equ	ADCSRA	= 0x06
                 .equ	ADCH	= 0x05
                 .equ	ADCL	= 0x04
                 .equ	ADCSRB	= 0x03
                 
                 
                 ; ***** BIT DEFINITIONS **************************************************
                 
                 ; ***** AD_CONVERTER *****************
                 ; ADMUX - The ADC multiplexer Selection Register
                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                 .equ	ADLAR	= 5	; Left Adjust Result
                 .equ	REFS0	= 6	; Reference Selection Bit 0
                 
                 ; ADCSRA - The ADC Control and Status register
                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                 .equ	ADIE	= 3	; ADC Interrupt Enable
                 .equ	ADIF	= 4	; ADC Interrupt Flag
                 .equ	ADATE	= 5	; ADC Auto Trigger Enable
                 .equ	ADSC	= 6	; ADC Start Conversion
                 .equ	ADEN	= 7	; ADC Enable
                 
                 ; ADCH - ADC Data Register High Byte
                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                 
                 ; ADCL - ADC Data Register Low Byte
                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                 
                 ; ADCSRB - ADC Control and Status Register B
                 .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
                 .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
                 .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
                 
                 ; DIDR0 - Digital Input Disable Register 0
                 .equ	ADC1D	= 2	; ADC2 Digital input Disable
                 .equ	ADC3D	= 3	; ADC3 Digital input Disable
                 .equ	ADC2D	= 4	; ADC2 Digital input Disable
                 .equ	ADC0D	= 5	; ADC0 Digital input Disable
                 
                 
                 ; ***** ANALOG_COMPARATOR ************
                 ; ADCSRB - ADC Control and Status Register B
                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                 
                 ; ACSR - Analog Comparator Control And Status Register
                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                 .equ	ACO	= 5	; Analog Compare Output
                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                 .equ	AINBG	= ACBG	; For compatibility
                 .equ	ACD	= 7	; Analog Comparator Disable
                 
                 ; DIDR0 - 
                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                 
                 
                 ; ***** EEPROM ***********************
                 ; EEAR - EEPROM Read/Write Access
                 .equ	EEARL	= EEAR	; For compatibility
                 .equ	EEAR0	= 0	; EEPROM Read/Write Access bit 0
                 .equ	EEAR1	= 1	; EEPROM Read/Write Access bit 1
                 .equ	EEAR2	= 2	; EEPROM Read/Write Access bit 2
                 .equ	EEAR3	= 3	; EEPROM Read/Write Access bit 3
                 .equ	EEAR4	= 4	; EEPROM Read/Write Access bit 4
                 .equ	EEAR5	= 5	; EEPROM Read/Write Access bit 5
                 
                 ; EEDR - EEPROM Data Register
                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                 
                 ; EECR - EEPROM Control Register
                 .equ	EERE	= 0	; EEPROM Read Enable
                 .equ	EEWE	= 1	; EEPROM Write Enable
                 .equ	EEPE	= EEWE	; For compatibility
                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                 .equ	EEMPE	= EEMWE	; For compatibility
                 .equ	EERIE	= 3	; EEProm Ready Interrupt Enable
                 .equ	EEPM0	= 4	; 
                 .equ	EEPM1	= 5	; 
                 
                 
                 ; ***** CPU **************************
                 ; SREG - Status Register
                 .equ	SREG_C	= 0	; Carry Flag
                 .equ	SREG_Z	= 1	; Zero Flag
                 .equ	SREG_N	= 2	; Negative Flag
                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                 .equ	SREG_S	= 4	; Sign Bit
                 .equ	SREG_H	= 5	; Half Carry Flag
                 .equ	SREG_T	= 6	; Bit Copy Storage
                 .equ	SREG_I	= 7	; Global Interrupt Enable
                 
                 ; SPL - Stack Pointer Low Byte
                 .equ	SP0	= 0	; Stack Pointer Bit 0
                 .equ	SP1	= 1	; Stack Pointer Bit 1
                 .equ	SP2	= 2	; Stack Pointer Bit 2
                 .equ	SP3	= 3	; Stack Pointer Bit 3
                 .equ	SP4	= 4	; Stack Pointer Bit 4
                 .equ	SP5	= 5	; Stack Pointer Bit 5
                 .equ	SP6	= 6	; Stack Pointer Bit 6
                 .equ	SP7	= 7	; Stack Pointer Bit 7
                 
                 ; MCUCR - MCU Control Register
                 .equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                 .equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                 .equ	SM0	= 3	; Sleep Mode Select Bit 0
                 .equ	SM1	= 4	; Sleep Mode Select Bit 1
                 .equ	SE	= 5	; Sleep Enable
                 .equ	PUD	= 6	; Pull-up Disable
                 
                 ; MCUSR - MCU Status register
                 .equ	PORF	= 0	; Power-On Reset Flag
                 .equ	EXTRF	= 1	; External Reset Flag
                 .equ	BORF	= 2	; Brown-out Reset Flag
                 .equ	WDRF	= 3	; Watchdog Reset Flag
                 
                 ; OSCCAL - Oscillator Calibration Register
                 .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
                 .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
                 .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
                 .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
                 .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
                 .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
                 .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
                 
                 ; CLKPR - Clock Prescale Register
                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                 
                 ; DWDR - Debug Wire Data Register
                 .equ	DWDR0	= 0	; Debug Wire Data Register Bit 0
                 .equ	DWDR1	= 1	; Debug Wire Data Register Bit 1
                 .equ	DWDR2	= 2	; Debug Wire Data Register Bit 2
                 .equ	DWDR3	= 3	; Debug Wire Data Register Bit 3
                 .equ	DWDR4	= 4	; Debug Wire Data Register Bit 4
                 .equ	DWDR5	= 5	; Debug Wire Data Register Bit 5
                 .equ	DWDR6	= 6	; Debug Wire Data Register Bit 6
                 .equ	DWDR7	= 7	; Debug Wire Data Register Bit 7
                 
                 ; SPMCSR - Store Program Memory Control and Status Register
                 .equ	SPMEN	= 0	; Store program Memory Enable
                 .equ	PGERS	= 1	; Page Erase
                 .equ	PGWRT	= 2	; Page Write
                 .equ	RFLB	= 3	; Read Fuse and Lock Bits
                 .equ	CTPB	= 4	; Clear Temporary Page Buffer
                 
                 
                 ; ***** PORTB ************************
                 ; PORTB - Data Register, Port B
                 .equ	PORTB0	= 0	; 
                 .equ	PB0	= 0	; For compatibility
                 .equ	PORTB1	= 1	; 
                 .equ	PB1	= 1	; For compatibility
                 .equ	PORTB2	= 2	; 
                 .equ	PB2	= 2	; For compatibility
                 .equ	PORTB3	= 3	; 
                 .equ	PB3	= 3	; For compatibility
                 .equ	PORTB4	= 4	; 
                 .equ	PB4	= 4	; For compatibility
                 .equ	PORTB5	= 5	; 
                 .equ	PB5	= 5	; For compatibility
                 
                 ; DDRB - Data Direction Register, Port B
                 .equ	DDB0	= 0	; 
                 .equ	DDB1	= 1	; 
                 .equ	DDB2	= 2	; 
                 .equ	DDB3	= 3	; 
                 .equ	DDB4	= 4	; 
                 .equ	DDB5	= 5	; 
                 
                 ; PINB - Input Pins, Port B
                 .equ	PINB0	= 0	; 
                 .equ	PINB1	= 1	; 
                 .equ	PINB2	= 2	; 
                 .equ	PINB3	= 3	; 
                 .equ	PINB4	= 4	; 
                 .equ	PINB5	= 5	; 
                 
                 
                 ; ***** EXTERNAL_INTERRUPT ***********
                 ; MCUCR - MCU Control Register
                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                 
                 ; GIMSK - General Interrupt Mask Register
                 .equ	GICR	= GIMSK	; For compatibility
                 .equ	PCIE	= 5	; Pin Change Interrupt Enable
                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                 
                 ; GIFR - General Interrupt Flag register
                 .equ	PCIF	= 5	; Pin Change Interrupt Flag
                 .equ	INTF0	= 6	; External Interrupt Flag 0
                 
                 ; PCMSK - Pin Change Enable Mask
                 .equ	PCINT0	= 0	; Pin Change Enable Mask Bit 0
                 .equ	PCINT1	= 1	; Pin Change Enable Mask Bit 1
                 .equ	PCINT2	= 2	; Pin Change Enable Mask Bit 2
                 .equ	PCINT3	= 3	; Pin Change Enable Mask Bit 3
                 .equ	PCINT4	= 4	; Pin Change Enable Mask Bit 4
                 .equ	PCINT5	= 5	; Pin Change Enable Mask Bit 5
                 
                 
                 ; ***** TIMER_COUNTER_0 **************
                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                 .equ	OCIE0A	= 2	; Timer/Counter0 Output Compare Match A Interrupt Enable
                 .equ	OCIE0B	= 3	; Timer/Counter0 Output Compare Match B Interrupt Enable
                 
                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                 .equ	OCF0A	= 2	; Timer/Counter0 Output Compare Flag 0A
                 .equ	OCF0B	= 3	; Timer/Counter0 Output Compare Flag 0B
                 
                 ; OCR0A - Timer/Counter0 Output Compare Register
                 .equ	OCR0A_0	= 0	; 
                 .equ	OCR0A_1	= 1	; 
                 .equ	OCR0A_2	= 2	; 
                 .equ	OCR0A_3	= 3	; 
                 .equ	OCR0A_4	= 4	; 
                 .equ	OCR0A_5	= 5	; 
                 .equ	OCR0A_6	= 6	; 
                 .equ	OCR0A_7	= 7	; 
                 
                 ; TCCR0A - Timer/Counter  Control Register A
                 .equ	WGM00	= 0	; Waveform Generation Mode
                 .equ	WGM01	= 1	; Waveform Generation Mode
                 .equ	COM0B0	= 4	; Compare Match Output B Mode
                 .equ	COM0B1	= 5	; Compare Match Output B Mode
                 .equ	COM0A0	= 6	; Compare Match Output A Mode
                 .equ	COM0A1	= 7	; Compare Match Output A Mode
                 
                 ; TCNT0 - Timer/Counter0
                 .equ	TCNT0_0	= 0	; 
                 .equ	TCNT0_1	= 1	; 
                 .equ	TCNT0_2	= 2	; 
                 .equ	TCNT0_3	= 3	; 
                 .equ	TCNT0_4	= 4	; 
                 .equ	TCNT0_5	= 5	; 
                 .equ	TCNT0_6	= 6	; 
                 .equ	TCNT0_7	= 7	; 
                 
                 ; TCCR0B - Timer/Counter Control Register B
                 .equ	CS00	= 0	; Clock Select
                 .equ	CS01	= 1	; Clock Select
                 .equ	CS02	= 2	; Clock Select
                 .equ	WGM02	= 3	; Waveform Generation Mode
                 .equ	FOC0B	= 6	; Force Output Compare B
                 .equ	FOC0A	= 7	; Force Output Compare A
                 
                 ; OCR0B - Timer/Counter0 Output Compare Register
                 .equ	OCR0B_0	= 0	; 
                 .equ	OCR0B_1	= 1	; 
                 .equ	OCR0B_2	= 2	; 
                 .equ	OCR0B_3	= 3	; 
                 .equ	OCR0B_4	= 4	; 
                 .equ	OCR0B_5	= 5	; 
                 .equ	OCR0B_6	= 6	; 
                 .equ	OCR0B_7	= 7	; 
                 
                 ; GTCCR - General Timer Conuter Register
                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter0
                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                 
                 
                 ; ***** WATCHDOG *********************
                 ; WDTCR - Watchdog Timer Control Register
                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                 .equ	WDE	= 3	; Watch Dog Enable
                 .equ	WDCE	= 4	; Watchdog Change Enable
                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                 .equ	WDTIE	= 6	; Watchdog Timeout Interrupt Enable
                 .equ	WDTIF	= 7	; Watchdog Timeout Interrupt Flag
                 
                 
                 
                 ; ***** LOCKSBITS ********************************************************
                 .equ	LB1	= 0	; Lockbit
                 .equ	LB2	= 1	; Lockbit
                 
                 
                 ; ***** FUSES ************************************************************
                 ; LOW fuse bits
                 .equ	CKSEL0	= 0	; Select Clock Source
                 .equ	CKSEL1	= 1	; Select Clock Source
                 .equ	SUT0	= 2	; Select start-up time
                 .equ	SUT1	= 3	; Select start-up time
                 .equ	CKDIV8	= 4	; Start up with system clock divided by 8
                 .equ	WDTON	= 5	; Watch dog timer always on
                 .equ	EESAVE	= 6	; Keep EEprom contents during chip erase
                 .equ	SPIEN	= 7	; SPI programming enable
                 
                 ; HIGH fuse bits
                 .equ	RSTDISBL	= 0	; Disable external reset
                 .equ	BODLEVEL0	= 1	; Enable BOD and select level
                 .equ	BODLEVEL1	= 2	; Enable BOD and select level
                 .equ	DWEN	= 3	; DebugWire Enable
                 .equ	SELFPRGEN	= 4	; Self Programming Enable
                 
                 
                 
                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                 .def	XH	= r27
                 .def	XL	= r26
                 .def	YH	= r29
                 .def	YL	= r28
                 .def	ZH	= r31
                 .def	ZL	= r30
                 
                 
                 
                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                 .equ	FLASHEND	= 0x01ff	; Note: Word address
                 .equ	IOEND	= 0x003f
                 .equ	SRAM_START	= 0x0060
                 .equ	SRAM_SIZE	= 64
                 .equ	RAMEND	= 0x009f
                 .equ	XRAMEND	= 0x0000
                 .equ	E2END	= 0x003f
                 .equ	EEPROMEND	= 0x003f
                 .equ	EEADRBITS	= 6
                 #pragma AVRPART MEMORY PROG_FLASH 1024
                 #pragma AVRPART MEMORY EEPROM 64
                 #pragma AVRPART MEMORY INT_SRAM SIZE 64
                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                 
                 
                 
                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                 .equ	PAGESIZE	= 16
                 
                 
                 
                 ; ***** INTERRUPT VECTORS ************************************************
                 .equ	INT0addr	= 0x0001	; External Interrupt 0
                 .equ	PCI0addr	= 0x0002	; External Interrupt Request 0
                 .equ	OVF0addr	= 0x0003	; Timer/Counter0 Overflow
                 .equ	ERDYaddr	= 0x0004	; EEPROM Ready
                 .equ	ACIaddr	= 0x0005	; Analog Comparator
                 .equ	OC0Aaddr	= 0x0006	; Timer/Counter Compare Match A
                 .equ	OC0Baddr	= 0x0007	; Timer/Counter Compare Match B
                 .equ	WDTaddr	= 0x0008	; Watchdog Time-out
                 .equ	ADCCaddr	= 0x0009	; ADC Conversion Complete
                 
                 .equ	INT_VECTORS_SIZE	= 10	; size in words
                 
                 #endif  /* _TN13DEF_INC_ */
                 
                 ; ***** END OF FILE ******************************************************
                 
                  * LittleThermo.asm
                  *
                  *  Created: 16.10.2014 16:14:39
                  *   Author: vlad
                  */ 
                 
                  .include "avr.inc"
                 
                 ; Constants
                 
                 .equ	RAMTOP = 0x60
                 
                 
                 
                 .equ	bit0	= 0b00000001
                 .equ	bit1	= 0b00000010
                 .equ	bit2	= 0b00000100
                 .equ	bit3	= 0b00001000
                 .equ	bit4	= 0b00010000
                 .equ	bit5	= 0b00100000
                 .equ	bit6	= 0b01000000
                 .equ	bit7	= 0b10000000
                 
                 
                 
                 ;------------------------------------------------;
                 ; Load immediate word into the resister pair.
                 ;
                 ;	ldiw	Z,var
                 
                 .macro	ldiw
                 	ldi	@0L,low(@1)
                 	ldi	@0H,high(@1)
                 .endm
                 
                 
                 .macro	pushw
                 	push	@0L
                 	push	@0H
                 .endm
                 
                 .macro	popw
                 	pop		@0H
                 	pop		@0L
                 .endm
                 
                 ;------------------------------------------------;
                 ; Load memory word into the resister pair.
                 ;
                 ;	ldsw	Z,mem
                 
                 .macro	ldsw
                 	lds	@0L,@1
                 	lds	@0H,@1+1
                 .endm
                 
                 .macro	lddw
                 	ldd	@0L,@1
                 	ldd	@0H,@1+1
                 .endm
                 
                 
                 ;------------------------------------------------;
                 ; Store resister pair into memory
                 ;
                 ;	stsw	mem,Z
                 
                 .macro	stsw
                 	sts	@0,@1L
                 	sts	@0+1,@1H
                 .endm
                 
                 .macro	stdw
                 	std	@0,@1L
                 	std	@0+1,@1H
                 .endm
                 
                 
                 ;------------------------------------------------;
                 ; Store immediate into the indirect memory
                 ;
                 ;	sti	Z,imm
                 ;	stdi	Z+d,imm
                 
                 .macro	sti
                 	ldi	r16,@1
                 	st	@0,r16
                 .endm
                 
                 .macro	stdi
                 	ldi	r16,@1
                 	std	@0,r16
                 .endm
                 
                 
                 ;------------------------------------------------;
                 ; Add/Subtract immediate to register
                 ;
                 ;	addi	var,imm
                 
                 .macro	addi
                 	subi	@0,-(@1)
                 .endm
                 
                 .macro	addiw
                 	subi	@0L,low(-(@1))
                 	sbci	@0H,high(-(@1))
                 .endm
                 
                 .macro	subiw
                 	subi	@0L,low(@1)
                 	sbci	@0H,high(@1)
                 .endm
                 
                 
                 ;------------------------------------------------;
                 ; Add/Subtract/Compare register pair
                 ;
                 
                 .macro	addw
                 	add	@0L,@1L
                 	adc	@0H,@1H
                 .endm
                 
                 .macro	subw
                 	sub	@0L,@1L
                 	sbc	@0H,@1H
                 .endm
                 
                 .macro	cpw
                 	cp	@0L,@1L
                 	cpc	@0H,@1H
                 .endm
                 
                 .macro	cpwi
                 	cpi		@0H, High(@1)
                 	brcs	PC+2
                 	cpi		@0L, Low(@1)
                 .endm
                 
                 ;------------------------------------------------;
                 ; Store immediate into the direct memory
                 ;
                 ;	stsi	var,imm
                 
                 .macro	stsi
                 	ldi	r16,@1
                 	sts	@0,r16
                 .endm
                 
                 .macro stswi
                 	stsi	@0	, Low(@1)
                 	stsi	@0+1, High(@1)	
                 .endm
                 
                 ;------------------------------------------------;
                 ; Input universal
                 ;
                 ;	uin	var, port
                 
                 .macro    uin
                   	.if	@1 < 0x40
                     	in	@0,@1         
                 	.else
                       	lds	@0,@1
                 .endif
                 .endm
                 
                 
                 ;------------------------------------------------;
                 ; Output universal
                 ;
                 ;	uout	port,var
                 
                 .macro    uout
                   	.if	@0 < 0x40
                     	OUT	@0,@1         
                 	.else
                       	STS	@0,@1
                 .endif
                 .endm
                 
                 ;------------------------------------------------;
                 ; Output immediate
                 ;
                 ;	outi	port,var
                 
                 .macro	outi
                 	ldi		r16,@1
                 	uout	@0,r16
                 .endm
                 
                 
                 ;------------------------------------------------;
                 ; Long branch
                 
                 
                 .macro	rjne
                 	breq	PC+2
                 	rjmp	@0
                 .endm
                 
                 .macro	rjeq
                 	brne	PC+2
                 	rjmp	@0
                 .endm
                 
                 .macro	rjcc
                 	brcs	PC+2
                 	rjmp	@0
                 .endm
                 
                 .macro	rjcs
                 	brcc	PC+2
                 	rjmp	@0
                 .endm
                 
                 .macro	retcc
                 	brcs	PC+2
                 	ret
                 .endm
                 
                 .macro	retcs
                 	brcc	PC+2
                 	ret
                 .endm
                 
                 .macro	reteq
                 	brne	PC+2
                 	ret
                 .endm
                 
                 .macro	retne
                 	breq	PC+2
                 	ret
                 .endm
                 
                 .macro	retts
                 	brtc	PC+2
                 	ret
                 .endm
                 
                 .macro	rettc
                 	brts	PC+2
                 	ret
                 
                 .EQU	led1 = PB0
                 .EQU	led2 = PB1
                 .EQU	led3 = PB2
                 
                 //#define	F_CPU 8000000
                 #define	F_CPU 9600000
                 
                 ;----------------------------------------------------------;
                 ; Data memory area
                 
                 .dseg
                 .ORG	RAMTOP
                 .EQU	MaxInputSize	=	32 
000060           LineBuf:.byte	MaxInputSize	;Command line characters buffer 
000080           ByteBuf:.byte	MaxInputSize/2  ;Command line bytes buffer
                 
                 ;----------------------------------------------------------;
                 ; Program code area
                 
                 .CSEG
                 .ORG $0000
                 
000000 c009      rjmp RESET ; Address 0x0000
                 /*
                 ; Tiny 25/45/85 
                 RETI	;	rjmp INT0_ISR ; Address 0x0001
                 RETI	;	rjmp PCINT0_ISR ; Address 0x0002
                 RETI	;	rjmp TIM1_COMPA_ISR ; Address 0x0003
                 RETI	;	rjmp TIM1_OVF_ISR ; Address 0x0004
                 RETI	;	rjmp TIMER_ISR ;	rjmp TIM0_OVF_ISR ; Address 0x0005
                 RETI	;	rjmp EE_RDY_ISR ; Address 0x0006
                 RETI	;	rjmp ANA_COMP_ISR ; Address 0x0007
                 RETI	;	rjmp ADC_ISR ; Address 0x0008
                 RETI	;	rjmp TIM1_COMPB_ISR ; Address 0x0009
                 RETI	;	rjmp TIM0_COMPA_ISR ; Address 0x000A
                 RETI	;	rjmp TIM0_COMPB_ISR ; Address 0x000B
                 RETI	;	rjmp WDT_ISR ; Address 0x000C
                 RETI	;	rjmp USI_START_ISR ; Address 0x000D
                 RETI	;	rjmp USI_OVF_ISR ; Address 0x000E
                 */
                 ;Tiny13
000001 9518      RETI	;	rjmp EXT_INT0 ; IRQ0 Handler
000002 9518      RETI	;	rjmp PCINT0 ; PCINT0 Handler
000003 9518      RETI	;	rjmp TIM0_OVF ; Timer0 Overflow Handler
000004 9518      RETI	;	rjmp EE_RDY ; EEPROM Ready Handler
000005 9518      RETI	;	rjmp ANA_COMP ; Analog Comparator Handle
000006 9518      RETI	;	rjmp TIM0_COMPA ; Timer0 CompareA Handler
000007 9518      RETI	;	rjmp TIM0_COMPB ; Timer0 CompareB Handler
000008 9518      RETI	;	rjmp WATCHDOG ; Watchdog Interrupt Handl
000009 9518      RETI	;	rjmp ADC ; ADC Conversion Handler
                 
                 ;----------------------------------------------------------;
                 ; Initialize
                 
                 RESET:
00000a e90f
00000b bf0d      	outi	SPL,low(RAMEND)		;
                 ;	outi	SPH,high(RAMEND)	;
00000c e007
00000d bb07      	outi	DDRB, (1<<led1)|(1<<led2)|(1<<led3)
00000e ef0f
00000f bb08      	outi	PORTB, 0xff			; Pullup		
                 
                 
                 ;----------------------------------------------------------;
                 ; Main loop
                 
                 main:
                 ;rcall	SearchOneWire
000010 d001      	rcall	ReadOneWire
                 
000011 cffe      	rjmp	main
                 
                 .MACRO OW_cmd
                 	ldi r16,@0 
                 	rcall	OWWriteByte
                 .ENDMACRO
                 
                 
                 ;----------------------------------------------------------;
                 ; Read temperature from _all_ connected devices, and read first result
                 ReadOneWire:
000012 d032      	rcall	OWReset
                 
                 	// индикация наличия устройства
                 //	in		r16, PINB
                 //	ori		r16, (1<<led)
                 //	bld		r16, led		; загрузить из T в led бит (если бит равен 0), то устройство на i2c есть и зажигаем диод
                 //	out		PORTB, r16
                 
000013 ec0c
000014 d04d      	OW_cmd	0xCC			; адресуемся ко всему
000015 e404
000016 d04b      	OW_cmd	0x44			; dallas - measure
                 
000017 e604      	ldi		r16, 100
000018 d021      	rcall	WaitMiliseconds
                 
000019 d02b      	rcall	OWReset
                 
                 //	OW_cmd	0x55			; адресуемся к конкретному
                 //	rcall	OWSendROM_NO	; адрес конкретного
00001a ec0c
00001b d046      	OW_cmd	0xCC			; адресуемся ко всему
                 
00001c eb0e
00001d d044          OW_cmd	0xBE			; читаем память
                 
                 read_temp_onewire:			; читаем и преобразуем температуру
00001e d05e      	rcall	OWReadByte		; младший байт HI - младшие разряды целых, LO - десятые
00001f 2f10      	mov		r17, r16		
000020 d05c      	rcall	OWReadByte		; старший байт LO - старшие разряды целых
000021 3008      	cpi		r16, 0x08			; проверям на отрицательность
000022 f008      	brlo	temp_up_zerro	; выше нуля - уходим
                 	; тут надо сделать преобразование из дополненного кода
000023 7007      	andi	r16, 0x07		; пока просто отсечем биты знака (что не правильно)
                 temp_up_zerro:
000024 7f10      	andi	r17, 0xf0		; HI(R17) = младшие знаки температуры
000025 2b10      	or		r17, r16		; HI(R17)- младшие, LO(R17) - старшие
000026 9512      	swap	r17				; теперь все на своих местах
                 
000027 9ac0      	sbi		PORTB, led1		; turn off
000028 9ac1      	sbi		PORTB, led2		; turn off
000029 9ac2      	sbi		PORTB, led3		; turn off
                 
00002a 3312      	cpi		r17, 50
00002b f010      	brlo	less50
00002c 98c2      	cbi		PORTB, led3		; hi temp
00002d 9508      	ret
                 less50:
00002e 3218      	cpi		r17, 40
00002f f010      	brlo	less40	
000030 98c1      	cbi		PORTB, led2
000031 9508      	ret
                 less40:
000032 311e      	cpi		r17, 30
000033 f010      	brlo	less30	
000034 98c0      	cbi		PORTB, led1
000035 9508      	ret
                 less30:
000036 9508      	ret
                 
                 .include "1-wire.asm"
                 
                 ; http://avr-mcu.dxp.pl
                 ; (c) Radoslaw Kwiecien, 2008
                 ; 
                 ; Перевод StarXXX, http://hardisoft.ru, 2009
                 ;------------------------------------------------------------------------------
                 
                 
                 
                 ;------------------------------------------------------------------------------
                 ; Начальные установки для реализации протокола 1-Wire
                 ;------------------------------------------------------------------------------
                 .equ	OW_PORT	= PORTB				; Порт МК, где висит 1-Wire
                 .equ	OW_PIN	= PINB				; Порт МК, где висит 1-Wire
                 .equ	OW_DDR	= DDRB				; Порт МК, где висит 1-Wire
                 .equ	OW_DQ	= PB4				; Ножка порта, где висит 1-Wire
                 
                 .def	OWCount = r17				; Счетчик
                 ;------------------------------------------------------------------------------
                 
                 
                 .cseg
                 
                 .include 	"wait.asm"			; Подключаем модуль временных задержек
                 
                 ; Busy-wait loops utilities module
                 ; For F_CPU >= 4MHz
                 ; http://avr-mcu.dxp.pl
                 ; (c) Radoslaw Kwiecien, 2008
                 ; 
                 ; Перевод StarXXX, http://hardisoft.ru, 2009
                 ;------------------------------------------------------------------------------
                 
                 ;------------------------------------------------------------------------------
                 ; Модуль временных задержек
                 ;
                 ; !!! Для работы модуля необходимо объявить константу F_CPU равную тактовой частоте в герцах !!!
                 ;
                 ; !!! задержки действительны для тактовой частоты >= 4 МГц !!!
                 
                 
                 ; задержки приблизительны! Чем больше задержка, тем точнее,
                 ; т.е. при частоте 4МГц задержка в 1 микросекунду, учитывая время вызова подпрограммы и возврата из нее составит 2,5 микросекунды
                 ; задержка в 10 микросекунд составит 11,5 микросекунд
                 ; задержка в 100 мкс на самом деле будет 101,5 мкс
                 ; тоесть, к каждой задержке добавится 1,5 мкс - это время на вызов подпрограммы и на выход из нее
                 ;------------------------------------------------------------------------------
                 
                 
                 
                 #ifndef F_CPU
                 #endif
                 
                 #if F_CPU < 4000000
                 #endif
                 
                 
                 #define CYCLES_PER_US (F_CPU/1000000)	; количество такотв на микросекунду
                 #define C4PUS (CYCLES_PER_US/4)		; 4 такта на одну микросекунду
                 #define DVUS(x) (C4PUS*x)		; вычисляет величину для указанного времени в микросекундах, которую нужно передать Wait4xCycles чтобы получить желаемую задержку
                 
                 ;--------------------------------------------------------------------------------------------------------------
                 ; Подпрограмма задержки. В цикле отъедается 4 такта на каждую итерацию, кроме последней. В последней - 3 такта.
                 ; Итого, для получения нужной задержки в микросекундах надо вызывать эту функцию предварительно
                 ; обработав параметр макросом DVUS:
                 ;	ldi    XH, HIGH(DVUS(500))
                 ; 	ldi    XL, LOW(DVUS(500))
                 ; 	rcall  Wait4xCycles ; пауза 500 микросекунд
                 ;--------------------------------------------------------------------------------------------------------------
                 ; Input : XH:XL - number of CPU cycles to wait (divided by four)
                 ;--------------------------------------------------------------------------------------------------------------
                 Wait4xCycles:
000037 9711      	sbiw	XH:XL, 1			; 2 такта
000038 f7f1      	brne	Wait4xCycles		; 1/2
000039 9508      	ret							; 4
                 
                 
                 ;------------------------------------------------------------------------------
                 ; Подпрограмма генерирует необходимую задержку в милисекундах
                 ; На входе: r16 = количество милисекунд
                 ;------------------------------------------------------------------------------
                 ; Input : r16 - number of miliseconds to wait
                 ;------------------------------------------------------------------------------
                 WaitMiliseconds:
00003a 930f      	push 	r16
                 WaitMsLoop: 
00003b e0b3      	ldi    XH,HIGH(DVUS(500))
00003c eea8      	ldi    XL,LOW(DVUS(500))
00003d dff9      	rcall  Wait4xCycles
00003e e0b3      	ldi    XH,HIGH(DVUS(500))
00003f eea8      	ldi    XL,LOW(DVUS(500))
000040 dff6      	rcall  Wait4xCycles
000041 950a      	dec    r16
000042 f7c1      	brne   WaitMsLoop
000043 910f      	pop    r16
000044 9508      	ret
                 ;------------------------------------------------------------------------------
                 ; End of file
                 ;------------------------------------------------------------------------------
                 
                 ;------------------------------------------------------------------------------
                 ; СБРОС
                 ; Каждая передача по протоколу 1-Wire начинается с сигнала Reset.
                 ; После вызова этой процедуры в флаге Т регистра SGER содержится бит 
                 ; присутствия: 1 - если на шине нет устройств, 0 - если есть
                 ;------------------------------------------------------------------------------
                 ; Output : T - presence bit
                 ;------------------------------------------------------------------------------
                 OWReset:
000045 98c4      	cbi		OW_PORT,OW_DQ		; Выводим в порт 0
000046 9abc      	sbi		OW_DDR,OW_DQ		; Переключаем порт на вывод
                 
000047 e0b3      	ldi		XH, HIGH(DVUS(470))	; Ждем 470 микросекунд при придавленной в 0 линии. Это и есть импульс сброса.
000048 eaac      	ldi		XL, LOW(DVUS(470))
000049 dfed      	rcall		Wait4xCycles
                 	
00004a 98bc      	cbi		OW_DDR,OW_DQ		; Переключаем порт на ввод
                 
00004b e0b0      	ldi		XH, HIGH(DVUS(70))	; выжидаем 70 мкс (необходимое минимальное время реакции устройств на сброс)
00004c e8ac      	ldi		XL, LOW(DVUS(70))
00004d dfe9      	rcall		Wait4xCycles
                 
00004e 9468      	set							; Устанавливаем флаг Т в 1
00004f 9bb4      	sbis	OW_PIN,OW_DQ		; Если на линии после паузы осталась 1, значит устройств 1-Wire на ней нет. Пропускаем след. команду
000050 94e8      	clt							; Линия была в 0 - значит на ней кто-то есть, и ответил нам импульсом PRESENCE
                 
000051 e0b1      	ldi		XH, HIGH(DVUS(240))	; Пауза 240 мкс после сброса
000052 eea0      	ldi		XL, LOW(DVUS(240))
000053 dfe3      	rcall		Wait4xCycles
                 
000054 9508      	ret
                 
                 
                 ;------------------------------------------------------------------------------
                 ; ОТПРАВКА 1 БИТА
                 ; Эта процедура отправляет 1 бит в линию 1-Wire.
                 ; Отправляемый бит должен быть помещен в флаг С статусного регистра
                 ;------------------------------------------------------------------------------
                 ; Input : C - bit to write
                 ;------------------------------------------------------------------------------
                 OWWriteBit:
000055 f418      	brcc	OWWriteZero			; Если флаг С = 0, то переход на OWWriteZero
000056 e0b0      	ldi		XH, HIGH(DVUS(1))	; Для посылки 1 линию нужно придавить в 0 всего на 1 мкс
000057 e0a2      	ldi		XL, LOW(DVUS(1))
000058 c002      	rjmp	OWWriteOne			; переходим к отправке
                 OWWriteZero:	
000059 e0b0      	ldi		XH, HIGH(DVUS(120))	; Для посылки 0 линию нужно придавить в 0 на 120 мкс
00005a efa0      	ldi		XL, LOW(DVUS(120))
                 OWWriteOne:
00005b 9abc      	sbi		OW_DDR, OW_DQ		; Переводим порт на выход, а там уже был 0, соответственно и линия придавливается в 0
00005c dfda      	rcall	Wait4xCycles		; ждем
00005d 98bc      	cbi		OW_DDR, OW_DQ		; Переводим порт на вход
                 	
00005e e0b0      	ldi		XH, HIGH(DVUS(60))	; Должна быть пауза между таймслотами, вообще-то от 1 мкс, но здесь сделали 60 мкс
00005f e7a8      	ldi		XL, LOW(DVUS(60))
000060 dfd6      	rcall	Wait4xCycles
000061 9508      	ret
                 
                 
                 ;------------------------------------------------------------------------------
                 ; ОТПРАВКА 1 БАЙТА
                 ; Эта процедура отправляет 1 байт в линию 1-Wire.
                 ; Отправляемый байт должен быть помещен в регистр r16
                 ;------------------------------------------------------------------------------
                 ; Input : r16 - byte to write
                 ;X,r16 - broken!
                 ;------------------------------------------------------------------------------
                 OWWriteByte:
000062 931f      	push	OWCount			; Сохраняем регистр счетчика
000063 e010      	ldi		OWCount,0		; Взводим в нём нолик
                 
                 OWWriteLoop:				
000064 9507      	ror		r16				; Сдвигаем байт вправо через флаг C
000065 dfef      	rcall	OWWriteBit		; отправляем в линию
000066 9513      	inc		OWCount			; увеличиваем счетчик
000067 3018      	cpi		OWCount,8		; проверяем на 8
000068 f7d9      	brne	OWWriteLoop		; если меньше - следующий бит
000069 911f      	pop		OWCount			; восстанавливаем регистр-счетчик
00006a 9508      	ret
                 
                 
                 
                 ;------------------------------------------------------------------------------
                 ; ЧТЕНИЕ 1 БИТА
                 ; Эта процедура читает 1 бит из линии 1-Wire.
                 ; Принятый бит помещается в флаг С статусного регистра
                 ;------------------------------------------------------------------------------
                 ; Output : C - bit from slave
                 ;------------------------------------------------------------------------------
                 OWReadBit:
00006b e0b0      	ldi		XH, HIGH(DVUS(1))	; Придавливаем линию в 0 на 1 мкс
00006c e0a2      	ldi		XL, LOW(DVUS(1))
00006d 9abc      	sbi		OW_DDR, OW_DQ
00006e dfc8      	rcall	Wait4xCycles
                 
00006f 98bc      	cbi		OW_DDR, OW_DQ		; Переводим порт на чтение
000070 e0b0      	ldi		XH, HIGH(DVUS(5))	; ждем 5 мкс
000071 e0aa      	ldi		XL, LOW(DVUS(5))
000072 dfc4      	rcall	Wait4xCycles
                 
000073 94e8      	clt							; Сбрасываем флаг Т
000074 99b4      	sbic	OW_PIN,OW_DQ		; Если на линии 0 - то пропускаем следующую команду
000075 9468      	set
                 
                 								; Итак, сейчас в регистре Т полученный бит
                 
000076 e0b0      	ldi		XH, HIGH(DVUS(50))	; выжидаем 50 мкс для окончания таймслота
000077 e6a4      	ldi		XL, LOW(DVUS(50))
000078 dfbe      	rcall	Wait4xCycles
                 								; переносим флаг Т в флаг С
000079 9408      	sec
00007a f00e      	brts	OWReadBitEnd
00007b 9488      	clc
                 
                 OWReadBitEnd:
00007c 9508      	ret
                 
                 
                 
                 ;------------------------------------------------------------------------------
                 ; ЧТЕНИЕ 1 БАЙТА
                 ; Эта процедура читает 1 байт из линии 1-Wire.
                 ; Принятый байт помещается регистр r16
                 ;------------------------------------------------------------------------------
                 ; Output : r16 - byte from slave
                 ;------------------------------------------------------------------------------
                 OWReadByte:
00007d 931f      	push	OWCount			; Сохраняем регистр-счетчик
00007e e010      	ldi		OWCount,0		; и обнуляем его
                 OWReadLoop:
00007f dfeb      	rcall	OWReadBit		; читаем бит
000080 9507      	ror		r16				; запихиваем его в r16 сдвигом вправо из флага С
000081 9513      	inc		OWCount			; увеличиваем счетчик
000082 3018      	cpi		OWCount,8		; уже 8?
000083 f7d9      	brne	OWReadLoop		; нет - продолжаем считывать
000084 911f      	pop		OWCount			; восстанавливаем регистр-счетчик
000085 9508      	ret
                 ;------------------------------------------------------------------------------
                 ;
                 ;------------------------------------------------------------------------------
                 
                 
                 .include 	"1-Wire Search.asm"		; Подключаем модуль поиска устройств на шине 1-Wire
                 
                 ; Поиск устройств на шине 1-Wire
                 ; Оригинал: Application Note 187. 1-Wire Search Algorithm by Dallas, С code
                 ; портировано на ассемблер: StarXXX, http://hardisoft.ru (c) 2009
                 ;***********************************************************************************
                 ; Порядок использования:
                 ;	1) Очистить ROM_NO вызовом подпрограммы OWClearROM_NO
                 ;	2) Произвести первый поиск вызовом подпрограммы OWFirst
                 ;	3) если флаг search_result в регистре search_flags = 1 тогда сохранить 
                 ;		найденный код ПЗУ из ROM_NO, произвести следующий поиск вызовом 
                 ;		подпрограммы OWNext и перейти к пункту 3
                 ;
                 ; Используемые регистры: r16, r17, r20 (search_flags)
                 ;
                 ; 
                 ; Поиск использует внешние подпрограммы:
                 ;
                 ;	OWReset - Выполняет сброс линии 1-Wire, принимает от устройств импульс
                 ;			присутствия PRESENCE. После вызова этой процедуры в флаге Т регистра 
                 ;			SREG содержится бит присутствия: 1 - если на шине нет устройств, 
                 ;			0 - если есть
                 ;
                 ;	OWWriteByte - Эта процедура отправляет 1 байт в линию 1-Wire. Отправляемый 
                 ;			байт должен быть помещен в регистр r16
                 ;	
                 ;	OWReadBit - Эта процедура читает 1 бит из линии 1-Wire. Принятый бит 
                 ;			помещается в флаг С регистра SREG
                 ;
                 ;	OWWriteBit - Эта процедура отправляет 1 бит в линию 1-Wire. Отправляемый 
                 ;			бит должен быть помещен в флаг С регистра SREG
                 ;
                 ;***********************************************************************************
                 
                 
                 ; Флаги
                 .equ		search_result		= 0
                 .equ		search_direction 	= 1
                 .equ		LastDeviceFlag		= 2
                 
                 ; Регистры
                 .def		search_flags		= r20
                 
                 
                 ;------------------------------------------------------------------------------
                 ; Поиск первого устройства на шине
                 ;------------------------------------------------------------------------------
                 OWFirst:
                     ; обнуление переменных
000086 2700      	clr		r16
000087 9300 0095 	sts		LastDiscrepancy, r16
000089 9300 0096 	sts		LastFamilyDiscrepancy, r16
00008b 9300 0090 	sts		stored_search_flags, r16
                 
00008d d001         	rcall 	OWNext
00008e 9508      	ret
                 
                 
                 ;------------------------------------------------------------------------------
                 ; Поиск следующего устройства на шине
                 ;------------------------------------------------------------------------------
                 OWNext:
00008f 9140 0090 	lds		search_flags, stored_search_flags	; Восстанавливаем флаги предыдущего поиска
                 
000091 2700         	clr 	r16
000092 9300 0094    	sts 	last_zero, r16						; last_zero = 0
000094 9300 0092    	sts 	rom_byte_number, r16				; rom_byte_number = 0
000096 9300 0097    	sts 	crc8, r16							; crc8 = 0
                 
000098 9503         	inc 	r16
000099 9300 0091    	sts 	id_bit_number, r16					; id_bit_number = 1
00009b 9300 0093    	sts 	rom_byte_mask, r16					; rom_byte_mask = 1
                 
00009d 7f4e      	cbr		search_flags, 1<<search_result		; search_result = FALSE
                 
00009e fd42      	sbrc	search_flags, LastDeviceFlag		; Это было последнее устройство?
00009f c086      	rjmp 	OWSItWasLastDevice					; Да - переходим на OWSItWasLastDevice
                 
                 
                 OWS_Reset:										; Сброс линии и проверка присутствия
0000a0 dfa4      	rcall 	OWReset
0000a1 f446      	brtc 	OWSResetOK
                 												; Никого нет? Тогда выходим
0000a2 2700      	clr 	r16
0000a3 9300 0095 	sts 	LastDiscrepancy, r16				; LastDiscrepancy = 0;
0000a5 9300 0096 	sts 	LastFamilyDiscrepancy, r16			; LastFamilyDiscrepancy = 0;
0000a7 7f4b      	cbr		search_flags, 1<<LastDeviceFlag		; LastDeviceFlag = FALSE;
0000a8 7f4e      	cbr		search_flags, 1<<search_result		; return FALSE;
                 
0000a9 c089      	rjmp	OWN_Return
                 
                 
                 OWSResetOK:
0000aa ef00      	ldi 	r16, 0xF0							; Посылаем команду поиска (0F)
0000ab 94f8      	cli
0000ac dfb5      	rcall 	OWWriteByte
0000ad 9478      	sei
                 
                 
                 OWS_do:											; Основной цикл поиска
0000ae 2700      	clr 	r16
0000af 2711      	clr 	r17
0000b0 6042      	sbr		search_flags, 1<<search_direction	; Сразу поставим search_direction=1, потом если что - сбросим
                 	
0000b1 94f8      	cli
0000b2 dfb8      	rcall 	OWReadBit							; читаем id_bit -> C
0000b3 1f00      	rol 	r16									; из флага C в нулевой бит r16
                 
0000b4 dfb6      	rcall 	OWReadBit							; читаем cmp_id_bit -> C
0000b5 1f11      	rol 	r17									; из флага C в нулевой бит r17
0000b6 9478      	sei
                 
0000b7 2300      	tst 	r16
0000b8 f019      	breq 	OWS_do_1_0
                 
0000b9 2311      	tst 	r17
0000ba f011      	breq 	OWS_do_1_1
0000bb c04e      	rjmp 	OWS_do_break						; id_bit = 1 и cmp_id_bit = 1 - на линии нет устройств!
                 
                 
                 OWS_do_1_0:
0000bc 7f4d      	cbr		search_flags, 1<<search_direction	; search_direction пока повторяет id_bit
                 
                 
                 OWS_do_1_1:										;  если id_bit не равен cmp_id_bit, тогда search_direction = id_bit
0000bd 1701      	cp 		r16, r17
0000be f4d9      	brne 	OWS_do_2
                 
                 	; Иначе - биты равны, тогда search_direction будет зависеть от id_bit_number и LastDiscrepancy
                 	
0000bf 6042      	sbr		search_flags, 1<<search_direction	; установим пока search_direction = 1
                 
0000c0 9100 0091 	lds 	r16, id_bit_number					; загружаем для проверки id_bit_number и LastDiscrepancy
0000c2 9110 0095 	lds		r17, LastDiscrepancy
                 
0000c4 1701      	cp 		r16, r17							; сравниваем
0000c5 f051      	breq	BitsEqual_End						; id_bit_number = LastDiscrepancy, значит оставляем search_direction = 1
0000c6 f440      	brcc	OWS_do_BitsEqual_else				; id_bit_number > LastDiscrepancy, значит установим search_direction = 0
                 
                 	; иначе id_bit_number < LastDiscrepancy, а это значит, что search_direction будет равен
                 	; значению текущего бита в ROM_NO
                 				
0000c7 d06e      	rcall	Calc_ROM_NO							; Получаем указатель на ROM_NO[rom_byte_number]
0000c8 8108      	ld		r16, y								; Получили в r16 ROM_NO[rom_byte_number]
0000c9 9110 0093 	lds		r17, rom_byte_mask					; Делаем ROM_NO[rom_byte_number] AND rom_byte_mask
0000cb 2301      	and		r16, r17
                 
0000cc f419      	brne	BitsEqual_End						; если после AND результат не нулевой, то оставим search_direction = 1
0000cd 7f4d      	cbr		search_flags, 1<<search_direction	; иначе переключим search_direction в 0
0000ce c001      	rjmp 	BitsEqual_End
                 
                 
                 OWS_do_BitsEqual_else:							; id_bit_number = LastDiscrepancy, значит оставляем search_direction = 1
0000cf 7f4d      	cbr		search_flags, 1<<search_direction
                 
                 
                 BitsEqual_End:
0000d0 fd41      	sbrc	search_flags, search_direction		; если search_direction = 0,
0000d1 c008      	rjmp 	OWS_do_2
                 
0000d2 9100 0091 	lds 	r16, id_bit_number					; тогда last_zero = id_bit_number
0000d4 9300 0094 	sts 	last_zero, r16
                 
                 	; проверка последнего различия в коде семейства.
0000d6 3009      	cpi 	r16, 9								; Если last_zero < 9
0000d7 f410      	brcc 	OWS_do_2
                 
0000d8 9300 0096 	sts 	LastFamilyDiscrepancy, r16  		; тогда LastFamilyDiscrepancy = last_zero;
                 
                 
                 OWS_do_2:
0000da d05b      	rcall	Calc_ROM_NO							; Получаем указатель на ROM_NO[rom_byte_number]
                 
                 	; Устанавливаем или сбрасываем бит в позиции rom_byte_mask байта rom_byte_number
                 	; в зависимости от search_direction
                 
0000db ff41      	sbrs	search_flags, search_direction		;если search_direction = 1
0000dc c005      	rjmp	OWS_do_2_1
                 
                 	; Тогда, устанавливаем бит в 1: ROM_NO[rom_byte_number] = ROM_NO[rom_byte_number] OR rom_byte_mask;
                 
0000dd 8108      	ld 		r16, y								; Получили в r16 ROM_NO[rom_byte_number]
0000de 9110 0093 	lds		r17, rom_byte_mask					; получили в r17 rom_byte_mask
0000e0 2b01      	or 		r16, r17							; сделали ROM_NO[rom_byte_number] OR rom_byte_mask
                 	
0000e1 c006      	rjmp 	OWS_do_2_2
                 
                 			
                 OWS_do_2_1:										
                 	; иначе search_direction = 1
                 	; Тогда сбрасываем бит в 0: ROM_NO[rom_byte_number] = ROM_NO[rom_byte_number] AND (rom_byte_mask XOR FF);
0000e2 9110 0093 	lds		r17, rom_byte_mask					; получили в r17 rom_byte_mask
0000e4 ef0f      	ldi		r16, 0xFF
0000e5 2710      	EOR		R17, R16							; инвертировали R17
                 
0000e6 8108      	ld 		r16, y								; Получили в r16 ROM_NO[rom_byte_number]
0000e7 2301      	AND		r16, r17							; сделали ROM_NO[rom_byte_number] AND (rom_byte_mask XOR FF)
                 
                 
                 OWS_do_2_2:
0000e8 8308      	ST 		y, r16								; записали назад в ROM_NO[rom_byte_number]
                 
0000e9 9408      	sec											; отсылаем бит search_direction в шину, чтобы заткнуть те устройства, у которых этот бит не такой
0000ea ff41      	sbrs	search_flags, search_direction		
0000eb 9488      	clc
0000ec 94f8      	cli
0000ed df67      	rcall 	OWWriteBit							
0000ee 9478      	sei
                 
0000ef 9100 0091 	lds 	r16, id_bit_number					; id_bit_number++;
0000f1 9503      	inc 	r16
0000f2 9300 0091 	sts 	id_bit_number, r16
                 
0000f4 9100 0093 	lds 	r16, rom_byte_mask					; Сдвигаем влево rom_byte_mask на 1 бит
0000f6 0f00      	lsl 	r16
0000f7 9300 0093 	sts 	rom_byte_mask, r16
0000f9 f459      	brne 	OWS_do_end							; если еще не все биты в текущем байте прошли - то бегом на следующую итерацию цикла поиска
                 
                 	; иначе добавляем CRC этого байта в общее CRC
                 
0000fa d03b      	rcall	Calc_ROM_NO							; Получаем указатель на ROM_NO[rom_byte_number]
0000fb 8108      	ld		r16, y								; Получили в r16 ROM_NO[rom_byte_number]
                 
0000fc d051      	rcall 	docrc8								; CRC готова
                 
0000fd 9100 0092 	lds 	r16, rom_byte_number				; rom_byte_number = rom_byte_number+1;
0000ff 9503      	inc 	r16
000100 9300 0092 	sts 	rom_byte_number, r16
                 
000102 e001      	ldi 	r16, 1								; Сбрасываем битовую маску в 1
000103 9300 0093 	sts 	rom_byte_mask, r16
                 
                 
                 OWS_do_end:										; Крутим цикл пока rom_byte_number < 8
000105 9100 0092 	lds 	r16, rom_byte_number
000107 3008      	cpi 	r16, 8
000108 f408      	brcc 	OWS_do_break
000109 cfa4      	rjmp 	OWS_do
                 
                 
                 	; если поиск прошел успешно, тогда id_bit_number будет больше 64 и crc8 будет равна 0
                 OWS_do_break:
00010a 9100 0091 	lds 	r16, id_bit_number
00010c 3401      	cpi 	r16, 65
00010d f408      	brcc 	OWS_bo_break_0
00010e c017      	rjmp 	OWSItWasLastDevice					; id_bit_number < 65, ошибка!
                 
                 
                 OWS_bo_break_0:
00010f 9100 0097 	lds 	r16, crc8
000111 2300      	tst 	r16
000112 f009      	breq 	OWS_bo_break_00
000113 c012      	rjmp 	OWSItWasLastDevice					; crc8 не равно 0, ошибка!
                 
                 
                 OWS_bo_break_00:
                 	; Поиск удался, установим флаги и переменные
000114 9100 0094 	lds 	r16, last_zero						; LastDiscrepancy = last_zero;
000116 9300 0095 	sts 	LastDiscrepancy, r16
                 
000118 2300      	tst		r16									; если LastDiscrepancy = 0
000119 f409      	brne 	OWS_do_break_1
                 
00011a 6044      	sbr		search_flags, 1<<LastDeviceFlag		; то это был последний девайс на линии, LastDeviceFlag = 1
                 
                 
                 OWS_do_break_1:
00011b 9100 0096 	lds		r16, LastFamilyDiscrepancy
00011d 9110 0095 	lds		r17, LastDiscrepancy
00011f 1701      	cp		r16,r17								; если LastFamilyDiscrepancy == LastDiscrepancy
000120 f419      	brne	OWS_do_break_2
                 
000121 2700      	clr 	r16
000122 9300 0096 	sts		LastFamilyDiscrepancy, r16			; то LastFamilyDiscrepancy = 0
                 
                 
                 OWS_do_break_2:
000124 6041      	sbr		search_flags, 1<<search_result		; search_result = 1, ура, все ОК!
000125 c00d      	rjmp	OWN_Return
                 
                 
                 OWSItWasLastDevice:
000126 fd40      	sbrc	search_flags, search_result			; если search_result = 0
000127 c00b      	rjmp	OWN_Return
                 
000128 9100 0098 	lds		r16, ROM_NO
00012a 2300      	tst 	r16
00012b f439      	brne 	OWN_Return
                 	
                 	; Тогда сбрасываем флаги и переменные так, чтобы следующий вызов этой подпрограммы был равносилем вызову OWFirst
00012c 7f4d      	cbr		search_flags, LastDeviceFlag		; LastDeviceFlag = 0
00012d 2700      	clr 	r16
00012e 9300 0095 	sts 	LastDiscrepancy, r16				; LastDiscrepancy = 0	
000130 9300 0096 	sts 	LastFamilyDiscrepancy, r16			; LastFamilyDiscrepancy = 0
000132 7f4e      	cbr		search_flags, 1<<search_result		; search_result = 0
                 
                 
                 OWN_Return:
000133 9340 0090 	sts		stored_search_flags, search_flags	; Сохраняем флаги для следующего поиска
000135 9508      	ret
                 
                 
                 
                 
                 
                 ;*********************************************************************		
                 ; 	Вычисляем указатель на ROM_NO[rom_byte_number]
                 ;
                 
                 calc_ROM_NO:
000136 e0d0      	ldi		yh, high(ROM_NO)					; указатель на ROM_NO
000137 e9c8      	ldi		yl, low (ROM_NO)
000138 9100 0092 	lds		r16, rom_byte_number				; прибавляем к нему rom_byte_number
00013a 2711      	clr		r17
00013b 0fc0      	add		yl, r16
00013c 1fd1      	adc		yh, r17
00013d 9508      	ret
                 
                 
                 
                 
                 
                 ;*********************************************************************		
                 ;   Очистка буфера ROM_NO
                 ; 	
                 OWClearROM_NO:
                 
00013e e0d0      	ldi yh, high(ROM_NO)			; указатель на ROM_NO
00013f e9c8      	ldi yl, low (ROM_NO)
                 
000140 e008      	ldi r16, 8
000141 2711      	clr r17
                 
                 OWCRN:
000142 9319      	st y+, r17
000143 950a      	dec r16
000144 f7e9      	brne OWCRN
                 			   
000145 9508      	ret
                 
                 
                 ;*********************************************************************		
                 ;   Отправляет буфер ROM_NO (для команды MATCH)
                 ; 	
                 OWSendROM_NO:
000146 e0d0      	ldi yh, high(ROM_NO)			; указатель на ROM_NO
000147 e9c8      	ldi yl, low (ROM_NO)
000148 e018      	ldi r17, 8						;счетчик байт
                 
                 OWSNDRN:
000149 9109      	ld r16, y+
00014a df17      	rcall	OWWriteByte
                 
00014b 951a      	dec r17
00014c f7e1      	brne OWSNDRN
                 			   
00014d 9508      	ret
                 
                 
                 
                 ;*********************************************************************		
                 ;   выполняет подсчет CRC по алгоритму 1-Wire
                 ; 	вход: r16 - считанный байт
                 ; 	выход: CRC - содержит подсчитанную сумму
                 ; 	портит: регистр Z
                 ; 	примечание: перед первым вызовом CRC необходимо обнулить
                 
                 docrc8:
00014e 9110 0097 	lds		r17, CRC8
000150 2701      	eor		r16, r17
                 	
000151 e0f1      	ldi		ZH, high(CRCtable)
000152 e5ed      	ldi		ZL, low(CRCtable)
000153 9488      	clc
000154 1fee      	rol		ZL
000155 1fff      	rol		ZH
000156 0fe0      	add		ZL, r16
000157 e010      	ldi		r17,0
000158 1ff1      	adc		ZH, r17
000159 9104      	lpm		r16, z
00015a 9300 0097 	sts		CRC8, r16
00015c 9508      	ret
                 
                 
                 CRCtable:
                 ; таблица сигнатур для быстрого расчета контрольной суммы CRC-8
00015d 5e00
00015e e2bc
00015f 3f61
000160 83dd
000161 9cc2
000162 207e
000163 fda3
000164 411f      	.db		0, 94, 188, 226, 97, 63, 221, 131, 194, 156, 126, 32, 163, 253, 31, 65
000165 c39d
000166 7f21
000167 a2fc
000168 1e40
000169 015f
00016a bde3
00016b 603e
00016c dc82      	.db 	157, 195, 33, 127, 252, 162, 64, 30, 95, 1, 227, 189, 62, 96, 130, 220
00016d 7d23
00016e c19f
00016f 1c42
000170 a0fe
000171 bfe1
000172 035d
000173 de80
000174 623c      	.db 	35, 125, 159, 193, 66, 28, 254, 160, 225, 191, 93, 3, 128, 222, 60, 98
000175 e0be
000176 5c02
000177 81df
000178 3d63
000179 227c
00017a 9ec0
00017b 431d
00017c ffa1      	.db 	190, 224, 2, 92, 223, 129, 99, 61, 124, 34, 192, 158, 29, 67, 161, 255
00017d 1846
00017e a4fa
00017f 7927
000180 c59b
000181 da84
000182 6638
000183 bbe5
000184 0759      	.db 	70, 24, 250, 164, 39, 121, 155, 197, 132, 218, 56, 102, 229, 187, 89, 7
000185 85db
000186 3967
000187 e4ba
000188 5806
000189 4719
00018a fba5
00018b 2678
00018c 9ac4      	.db 	219, 133, 103, 57, 186, 228, 6, 88, 25, 71, 165, 251, 120, 38, 196, 154
00018d 3b65
00018e 87d9
00018f 5a04
000190 e6b8
000191 f9a7
000192 451b
000193 98c6
000194 247a      	.db 	101, 59, 217, 135, 4, 90, 184, 230, 167, 249, 27, 69, 198, 152, 122, 36
000195 a6f8
000196 1a44
000197 c799
000198 7b25
000199 643a
00019a d886
00019b 055b
00019c b9e7      	.db 	248, 166, 68, 26, 153, 199, 37, 123, 58, 100, 134, 216, 91, 5, 231, 185
00019d d28c
00019e 6e30
00019f b3ed
0001a0 0f51
0001a1 104e
0001a2 acf2
0001a3 712f
0001a4 cd93      	.db 	140, 210, 48, 110, 237, 179, 81, 15, 78, 16, 242, 172, 47, 113, 147,205
0001a5 4f11
0001a6 f3ad
0001a7 2e70
0001a8 92cc
0001a9 8dd3
0001aa 316f
0001ab ecb2
0001ac 500e      	.db 	17, 79, 173, 243, 112, 46, 204, 146, 211, 141, 111, 49, 178, 236, 14, 80
0001ad f1af
0001ae 4d13
0001af 90ce
0001b0 2c72
0001b1 336d
0001b2 8fd1
0001b3 520c
0001b4 eeb0      	.db 	175, 241, 19, 77, 206, 144, 114, 44, 109, 51, 209, 143, 12, 82, 176, 238
0001b5 6c32
0001b6 d08e
0001b7 0d53
0001b8 b1ef
0001b9 aef0
0001ba 124c
0001bb cf91
0001bc 732d      	.db 	50, 108, 142, 208, 83, 13, 239, 177, 240, 174, 76, 18, 145, 207, 45, 115
0001bd 94ca
0001be 2876
0001bf f5ab
0001c0 4917
0001c1 5608
0001c2 eab4
0001c3 3769
0001c4 8bd5      	.db 	202, 148, 118, 40, 171, 245, 23, 73, 8, 86, 180, 234, 105, 55, 213, 139
0001c5 0957
0001c6 b5eb
0001c7 6836
0001c8 d48a
0001c9 cb95
0001ca 7729
0001cb aaf4
0001cc 1648      	.db 	87, 9, 235, 181, 54, 104, 138, 212, 149, 203, 41, 119, 244, 170, 72, 22
0001cd b7e9
0001ce 0b55
0001cf d688
0001d0 6a34
0001d1 752b
0001d2 c997
0001d3 144a
0001d4 a8f6      	.db 	233, 183, 85, 11, 136, 214, 52, 106, 43, 117, 151, 201, 74, 20, 246, 168
0001d5 2a74
0001d6 96c8
0001d7 4b15
0001d8 f7a9
0001d9 e8b6
0001da 540a
0001db 89d7
0001dc 356b      	.db 	116, 42, 200, 150, 21, 75, 169, 247, 182, 232, 10, 84, 215, 137, 107, 53
                 
                 
                 
                 
                 
                 ; Переменные, необходимые для работы процедуры поиска
                 .dseg
                 
000090 00        stored_search_flags:	.db	0
000091 00        id_bit_number: 			.db 0
000092 00        rom_byte_number:		.db 0
000093 00        rom_byte_mask:			.db 0
000094 00        last_zero:				.db 0
000095 00        LastDiscrepancy:		.db 0
000096 00        LastFamilyDiscrepancy:	.db 0
000097 00        crc8:					.db 0
000098           ROM_NO:					.byte 8
                 
                 
                 .cseg
                 
                 
                 
                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny13" register use summary:
r0 :   0 r1 :   0 r2 :   0 r3 :   0 r4 :   0 r5 :   0 r6 :   0 r7 :   0 
r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 r13:   0 r14:   0 r15:   0 
r16:  93 r17:  42 r18:   0 r19:   0 r20:  19 r21:   0 r22:   0 r23:   0 
r24:   0 r25:   0 r26:  12 r27:  12 r28:   4 r29:   4 r30:   3 r31:   3 
x  :   0 y  :   7 z  :   1 
Registers used: 11 out of 35 (31.4%)

"ATtiny13" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   2 add   :   2 adiw  :   0 and   :   2 
andi  :   2 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   5 brcs  :   0 break :   0 breq  :   4 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   4 brlt  :   0 brmi  :   0 
brne  :  12 brpl  :   0 brsh  :   0 brtc  :   1 brts  :   1 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 cbi   :   7 cbr   :   8 clc   :   3 
clh   :   0 cli   :   3 cln   :   0 clr   :   9 cls   :   0 clt   :   2 
clv   :   0 clz   :   0 com   :   0 cp    :   3 cpc   :   0 cpi   :   9 
cpse  :   0 dec   :   3 eor   :   2 icall :   0 ijmp  :   0 in    :   0 
inc   :   5 ld    :   5 ldd   :   0 ldi   :  46 lds   :  19 lpm   :   2 
lsl   :   1 lsr   :   0 mov   :   1 movw  :   0 neg   :   0 nop   :   0 
or    :   2 ori   :   0 out   :   3 pop   :   3 push  :   3 rcall :  33 
ret   :  17 reti  :   9 rjmp  :  15 rol   :   4 ror   :   2 sbc   :   0 
sbci  :   0 sbi   :   6 sbic  :   1 sbis  :   1 sbiw  :   1 sbr   :   4 
sbrc  :   3 sbrs  :   2 sec   :   2 seh   :   0 sei   :   3 sen   :   0 
ser   :   0 ses   :   0 set   :   2 sev   :   0 sez   :   0 sleep :   0 
spm   :   0 st    :   2 std   :   0 sts   :  22 sub   :   0 subi  :   0 
swap  :   1 tst   :   5 wdr   :   0 
Instructions used: 51 out of 105 (48.6%)

"ATtiny13" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0003ba    698    256    954    1024  93.2%
[.dseg] 0x000060 0x0000a0      0     64     64      64 100.0%
[.eseg] 0x000000 0x000000      0      0      0      64   0.0%

Assembly complete, 0 errors, 0 warnings
